from pwn import *

# https://stackoverflow.com/questions/4798654/modular-multiplicative-inverse-function-in-python
# solves for a small e
#bootlegsa3 2019 pico
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


ciphertext = 12027159045777220634966254164598495385908523152247648938389760969204271211357644355026694997656566613335291580857876116300218374376911749804306056945429342321543239250074729338858396627046343318942083699526308891381674845614727719228671581714596552080983432788943334453575515379208941992940520374911029242817934679278407314325049969660104283820

n = 24806847181535681540970678009401250373543223221844330601928122014071162228021484455477590748844350121107739788029291882379307941486102896510678059826910981388454561698136861904918961513187805233408417837731739749630950990304431218392071933541817747558190531316760909942249834150023243058933750019371440162687965795222139540222148511645973252011

e = 65537

phi = 24806847112652459018043657153538806368941706871986213018213639341256944233631615401298984135604767666454658877262249653240205297647808530024454939241902089515335694733789993682184127753687219355193545803537851313692914515864699859400772634711613376177417196900203220313350100290797310032302474567229787567985592063546932543412131751526400000000

d = modinv(e, phi)
m = pow(ciphertext, d, n)

flag = unhex(hex(m)[2:])

print 'flag: {}'.format(flag)